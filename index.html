

<head>
    <link rel="manifest" href="manifest.webmanifest">
</head>
<body>
    <canvas id="render-canvas"></canvas>
    <div id="user-interface">
        <img id="restart-btn" src="assets/restart.png" >
        <img id="coin-img" src="assets/coin.png">
        <p id="coin-score">0</p>
        <p id="score">0</p>
    </div>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Pangolin&display=swap');
        body, #render-canvas, #user-interface {
            margin: 0;
            width: 100%;
            height: 100vh;
            font-family: 'Black Ops One', cursive;
            user-select: none;
        }
        #restart-btn {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 200px;
        }
        #coin-img{
            position: absolute;
            top: 2vh;
            right: 2vh;
            width: 5vh;
        }
        #coin-score {
            position: absolute;
            top: -5vh;
            right: 8vh;
            font-size: 6vh;
        }
        #score {
            position: absolute;
            top: 10vh;
            width: 100%;
            text-align: center;
            font-size: 8vh;
        }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script>
        //СОЗДАНИЕ МИРА
        let canvas = document.querySelector('#render-canvas');
        //Создание движка
        let engine = new BABYLON.Engine(canvas);
        //Создание сцены и присоединение ее к движку
        let scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color3(0.3, 0.3, 0.3);
        scene.enablePhysics();
        scene.createDefaultEnvironment({
            createSkybox: false,
            createGround: false,
            cameraContrast: 2.5,
            cameraExposure: 1
        });
        //Создание камеры
        let camera = new BABYLON.FreeCamera('camera', new BABYLON.Vector3(0, 10, -15), scene);
        camera.setTarget(new BABYLON.Vector3(0, 0, 0));

        //создание света
        let light = new BABYLON.PointLight('light', new BABYLON.Vector3(10, 10, 0), scene);
        light.intensity = 0.15;

        //создание генератора теней
        let shadowGenerator = new BABYLON.ShadowGenerator(1024, light);

        //Создание платформы
        //let box = new BABYLON.Mesh.CreateBox('box', 2, scene);
        const createPlatform = (zPos) => {
            let platform = new BABYLON.MeshBuilder.CreateBox('box', {
                width: 6,
                height: 0.1,
                depth: 6,
                wrap: true
            }, scene);
            
            //создание материала
            let boxMaterial = new BABYLON.StandardMaterial('material', scene);
            //boxMaterial.emissiveColor = new BABYLON.Color3(0, 0.58, 0.86);
            boxMaterial.emissiveTexture = new BABYLON.Texture('assets/platform.png');
            platform.material = boxMaterial;
            platform.receiveShadows = true;
            platform.physicsImpostor = new BABYLON.PhysicsImpostor(
                platform,
                BABYLON.PhysicsImpostor.BoxImpostor,
                {
                    mass: 0
                },
                scene
            );
            platform.position.z = zPos;
        }

        for(let i = 0; i < 10; i++){
            createPlatform(i*6);
        }

        //создание монетки
        let coinArray = [];
        const createCoin = (pos) => {
            BABYLON.SceneLoader.ImportMesh(
                null, //указать для того чтобы подгрузить все объекты из файла 3д модели
                'assets/coin/',
                'scene.gltf',
                scene,
                (meshArray) => {
                    let coin = meshArray[0];
                    coin.scaling = new BABYLON.Vector3(0.08, 0.08, 0.08);
                    coin.position = pos;
                    shadowGenerator.addShadowCaster(coin);
                    coin.receiveShadows = true;
                    coinArray.push(coin);
                }
            );
        }

        //создание препятствий
        let lastRand = 0;
        let boxArray = [];
        let pointArray = [];
        const createBox = (xPos, zPos) => {
                let box = new BABYLON.MeshBuilder.CreateBox('box', {
                    width: 2,
                    height: 1,
                    depth: 1
                }, scene);
                box.position = new BABYLON.Vector3(xPos, 0.6, 3 + zPos);
                box.material = new BABYLON.StandardMaterial('material', scene);
                box.material.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                box.physicsImpostor = new BABYLON.PhysicsImpostor(
                    box,
                    BABYLON.PhysicsImpostor.BoxImpostor,
                    {
                        mass: 0
                    },
                    scene
                );
                shadowGenerator.getShadowMap().renderList.push(box);
                box.receiveShadows = true;
                boxArray.push(box);
        }
        const createBoxRow = (zPos) => {
            let rand = Math.floor(Math.random() * 3);
            while(rand === lastRand){
                rand = Math.floor(Math.random() * 3);
            }
            lastRand = rand;
            for(let i = 0; i < 3; i++){
                if(i === rand) {
                    if(Math.random() < 0.5) {
                        createCoin(new BABYLON.Vector3((i*2)-2, 1, 3+zPos));
                    }else{
                        //что то еще
                    }
                    pointArray.push(new BABYLON.Vector3((i*2)-2, 1, 3+zPos))    
                    continue;
                }
                createBox((i*2)-2, zPos);
            }
        }

        for(let i = 0; i < 10; i++){
            createBoxRow(i*6);
        }
        
        

        //создание мяча и материала для него
        let ball = new BABYLON.MeshBuilder.CreateSphere('sphere', {
            diametr: 1
        }, scene);
        ball.position.y = 5.6;

        let ballMaterial = new BABYLON.StandardMaterial('material', scene);
        ballMaterial.emissiveTexture = new BABYLON.Texture('assets/ball.png');
        ball.material = ballMaterial;
        shadowGenerator.getShadowMap().renderList.push(ball);
        ball.physicsImpostor = new BABYLON.PhysicsImpostor(
            ball,
            BABYLON.PhysicsImpostor.SphereImpostor,
            {
                mass: 1,
                friction: 5
            },
            scene
        );


        //алгоритм
        let restartBtn = window.document.querySelector('#restart-btn');
        let scoreInfo = window.document.querySelector('#score');
        let score = 0;
        let coinScoreInfo = window.document.querySelector('#coin-score');
        let coinScore = 0;
        
        //функции
        const saveCoinScore = () => {
            localStorage.setItem('coinScore', coinScore);
        }
        const loadCoinScore = () => {
            coinScore = (localStorage.getItem('coinScore'))
            ? localStorage.getItem('coinScore')
            : 0
            coinScoreInfo.innerText = coinScore;
        }

        loadCoinScore();

        //встроеные функции Babylon.js

        scene.registerBeforeRender(() => {
            for(let i = 0; i < boxArray.length; i++){
                if(ball.intersectsMesh(boxArray[i], true)){
                    boxArray[i].material.emissiveColor = new BABYLON.Color3(0.5, 0, 0);
                }
            }
            for(let i = 0; i < coinArray.length; i++){
                if(ball.intersectsMesh(coinArray[i], false)){
                    coinScore++;
                    coinScoreInfo.innerText = coinScore;
                    saveCoinScore();
                    coinArray[i].dispose();
                    coinArray.splice(i, 1);
                }
            }
            for(let i = 0; i < pointArray.length; i++){
                if(ball.intersectsPoint(pointArray[i])){
                    pointArray.splice(i, 1);
                    score++;
                    scoreInfo.innerText = score;
                }
            }
        });
        engine.runRenderLoop(() => {
            camera.position.z = ball.getAbsolutePosition().z - 12;
            light.position.z = ball.getAbsolutePosition().z;
            scene.render();
        });

        //обработчики событий 

        restartBtn.addEventListener('click', () => window.location.reload());

        window.addEventListener('touchstart', (event) => {
            let x = event.touches[0].screenX;

            if(x > (window.screen.width / 2)){
                ball.physicsImpostor.applyImpulse(
                new BABYLON.Vector3(10, 0, 0),
                ball.getAbsolutePosition()
            );
            }else {
                ball.physicsImpostor.applyImpulse(
                new BABYLON.Vector3(-10, 0, 0),
                ball.getAbsolutePosition()
            );
            }
            
        });
        window.addEventListener('touchend', () => {
            ball.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 5));
            ball.physicsImpostor.setAngularVelocity(new BABYLON.Vector3(0, 0, 0));
        });

        window.addEventListener('beforeinstallprompt', (event) => {
            event.preventDefault();
        });
    </script>
</body>